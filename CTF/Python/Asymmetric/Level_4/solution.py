"""

See the attachment for the challenge code. The output is:

136372941954692995052032614106416002216650352281441768759106047115825257661310123118558086046873251952204915740853517008372422353621244931866409094731856824295828106036399145756514345255241109944294641060644246049854296519101775880563276657142059245230769447888021843340822736997057074223723734593369646608283
[88934261481985787316571946676203348514352494646042103159736155624287938096099586834729171652139440814472420307071476143907698982272593448957770236088603490101924827608944006107576740571416087954304061091614594794358854353419664581332745351113861171522629631586344259719016707622211007808872462656489173218734, 31191490339291402076171068036548032381977184741778243810947202097002026583133103229115040414216968980627919985794378128894603186334221963211692252394535977554990491215621733091487550326776298499502932523408287882489799200954692353162958794137970552454035789701538315132727860436887544051794011893682559545564]

"""

# ─── Attack ──────────────────────────────────────────────────────────────────────
# Common‐modulus RSA key recovery via Extended Euclidean Algorithm 

# ─── Steps ──────────────────────────────────────────────────────────────────────
#   1. Compute integers s1, s2 such that s1*e1 + s2*e2 = 1 using the Extended GCD.
#   2. Reconstruct the plaintext: m = c1^s1 · c2^s2 mod n, using modular inverses for negative exponents.
#   3. Convert the resulting integer m back to bytes and print the recovered flag.

from Crypto.Util.number import inverse, long_to_bytes  # RSA utilities
import gmpy2                                            # for gcdext()

# ─── Public values (from challenge output) ──────────────────────────────────────
n = 136372941954692995052032614106416002216650352281441768759106047115825257661310123118558086046873251952204915740853517008372422353621244931366409094731856824295828106036399145756514345255241109944294641060644246049854296519101775880563276657142059245230769447888021843340822736997057074223723734593369646608283

# Two ciphertexts encrypted under the same modulus with exponents e1=31 and e2=71
c1 = 88934261481985787316571946676203348514352494646042103159736155624287938096099586834729171652139440814472420307071476143907698982272593448957770236088603490101924827608944006107576740571416087954304061091614594794358854353419664581332745351113861171522629631586344259719016707622211007808872462656489173218734
c2 = 31191490339291402076171068036548032381977184741778243810947202097002026583133103229115040414216968980627919985794378128894603186334221963211692252394535977554990491215621733091487550326776298499502932523408287882489799200954692353162958794137970552454035789701538315132727860436887544051794011893682559545564

e1 = 31
e2 = 71

# ─── Step 1: Compute s1, s2 via Extended GCD ────────────────────────────────────
# Find s1, s2 such that s1*e1 + s2*e2 = gcd(e1, e2) = 1
g, s1, s2 = gmpy2.gcdext(e1, e2)
assert g == 1 and s1*e1 + s2*e2 == 1

# ─── Step 2: Reconstruct the plaintext integer ───────────────────────────────────
# Handle negative coefficients by using modular inverses
if s1 < 0:
    part1 = pow(inverse(c1, n), -s1, n)
else:
    part1 = pow(c1, s1, n)

if s2 < 0:
    part2 = pow(inverse(c2, n), -s2, n)
else:
    part2 = pow(c2, s2, n)

m = (part1 * part2) % n

# ─── Step 3: Convert to bytes and print the flag ───────────────────────────────
flag = long_to_bytes(m)
print(flag.decode())



# ─── FLAG ───────────────────────────────────────────────────────────────────────
# CRYPTO25{2533166c-ce76-4f5e-b992-f7e4a24d0b97}
